{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the documentation home for Rojo 0.5.x. Available versions of these docs: Latest version (currently 0.5.x) 0.5.x 0.4.x Rojo is a flexible multi-tool designed for creating robust Roblox projects. This documentation is a continual work in progress. If you find any issues, please file an issue on Rojo's issue tracker !","title":"Home"},{"location":"creating-a-place/","text":"Creating the Rojo Project Building Your Place Live-Syncing into Studio Uploading Your Place Creating the Rojo Project \u00b6 To use Rojo to build a place, you'll need to create a new project file, which tells Rojo how your project is structured on-disk and in Roblox. Create a new folder, then run rojo init inside that folder to initialize an empty project. mkdir my-new-project cd my-new-project rojo init Rojo will make a small project file in your directory, named default.project.json . It'll make sure that any code in the directory src will get put into ReplicatedStorage.Source . Speaking of, let's make sure we create a directory named src , and maybe a Lua file inside of it: mkdir src echo 'print(\"Hello, world!\")' > src/hello.lua Building Your Place \u00b6 Now that we have a project, one thing we can do is build a Roblox place file for our project. This is a great way to get started with a project quickly with no fuss. All we have to do is call rojo build : rojo build -o MyNewProject.rbxlx If you open MyNewProject.rbxlx in Roblox Studio now, you should see a Folder containing a ModuleScript under ReplicatedStorage ! Info To generate a binary place file instead, use rbxl . Note that support for binary model/place files ( rbxm and rbxl ) is very limited in Rojo presently. Live-Syncing into Studio \u00b6 Building a place file is great for the initial build, but for actively working on your place, you'll want something quicker. In Roblox Studio, make sure the Rojo plugin is installed. If you need it, check out the installation guide to learn how to install it. To expose your project to the plugin, you'll need to serve it from the command line: rojo serve This will start up a web server that tells Roblox Studio what instances are in your project and sends notifications if any of them change. Note the port number, then switch into Roblox Studio and press the Rojo Connect button in the plugins tab. Type in the port number, if necessary, and press Start . If everything went well, you should now be able to change files in the src directory and watch them sync into Roblox Studio in real time! Uploading Your Place \u00b6 Aimed at teams that want serious levels of automation, Rojo can upload places to Roblox.com automatically. You'll need an existing place on Roblox.com as well as the .ROBLOSECURITY cookie of an account that has write access to that place. Warning It's recommended that you set up a Roblox account dedicated to deploying your place instead of your personal account in case your security cookie is compromised. Generating and uploading your place file is as simple as: rojo upload --asset_id [ PLACE ID ] --cookie \"[SECURITY COOKIE]\"","title":"Creating a Place with Rojo"},{"location":"creating-a-place/#creating-the-rojo-project","text":"To use Rojo to build a place, you'll need to create a new project file, which tells Rojo how your project is structured on-disk and in Roblox. Create a new folder, then run rojo init inside that folder to initialize an empty project. mkdir my-new-project cd my-new-project rojo init Rojo will make a small project file in your directory, named default.project.json . It'll make sure that any code in the directory src will get put into ReplicatedStorage.Source . Speaking of, let's make sure we create a directory named src , and maybe a Lua file inside of it: mkdir src echo 'print(\"Hello, world!\")' > src/hello.lua","title":"Creating the Rojo Project"},{"location":"creating-a-place/#building-your-place","text":"Now that we have a project, one thing we can do is build a Roblox place file for our project. This is a great way to get started with a project quickly with no fuss. All we have to do is call rojo build : rojo build -o MyNewProject.rbxlx If you open MyNewProject.rbxlx in Roblox Studio now, you should see a Folder containing a ModuleScript under ReplicatedStorage ! Info To generate a binary place file instead, use rbxl . Note that support for binary model/place files ( rbxm and rbxl ) is very limited in Rojo presently.","title":"Building Your Place"},{"location":"creating-a-place/#live-syncing-into-studio","text":"Building a place file is great for the initial build, but for actively working on your place, you'll want something quicker. In Roblox Studio, make sure the Rojo plugin is installed. If you need it, check out the installation guide to learn how to install it. To expose your project to the plugin, you'll need to serve it from the command line: rojo serve This will start up a web server that tells Roblox Studio what instances are in your project and sends notifications if any of them change. Note the port number, then switch into Roblox Studio and press the Rojo Connect button in the plugins tab. Type in the port number, if necessary, and press Start . If everything went well, you should now be able to change files in the src directory and watch them sync into Roblox Studio in real time!","title":"Live-Syncing into Studio"},{"location":"creating-a-place/#uploading-your-place","text":"Aimed at teams that want serious levels of automation, Rojo can upload places to Roblox.com automatically. You'll need an existing place on Roblox.com as well as the .ROBLOSECURITY cookie of an account that has write access to that place. Warning It's recommended that you set up a Roblox account dedicated to deploying your place instead of your personal account in case your security cookie is compromised. Generating and uploading your place file is as simple as: rojo upload --asset_id [ PLACE ID ] --cookie \"[SECURITY COOKIE]\"","title":"Uploading Your Place"},{"location":"installation/","text":"Overview Installing the CLI Installing from GitHub Installing from Cargo Installing the Plugin Installing from GitHub Installing from Roblox.com Visual Studio Code Extension Overview \u00b6 Rojo has two components: The command line interface (CLI) The Roblox Studio plugin Info It's important that your installed version of the plugin and CLI are compatible. The plugin will show errors in the Roblox Studio output window if there is a version mismatch. Installing the CLI \u00b6 Installing from GitHub \u00b6 If you're on Windows, there are pre-built binaries available from Rojo's GitHub Releases page . The Rojo CLI must be run from the command line, like Terminal.app on MacOS or cmd.exe on Windows. It's recommended that you put the Rojo CLI executable on your PATH to make this easier. Installing from Cargo \u00b6 If you have Rust installed, the easiest way to get Rojo is with Cargo! To install the latest 0.5.0 alpha, use: cargo install rojo --version 0 .5.0-alpha.11 Installing the Plugin \u00b6 Installing from GitHub \u00b6 The Rojo Roblox Studio plugin is available from Rojo's GitHub Releases page . Download the attached rbxm file and put it into your Roblox Studio plugins folder. You can find that folder by pressing Plugins Folder from your Plugins toolbar in Roblox Studio: Installing from Roblox.com \u00b6 Visit Rojo's Roblox.com Plugin page in Roblox Studio and press Install . Visual Studio Code Extension \u00b6 If you use Visual Studio Code, you can install Evaera's unofficial Rojo extension , which will install both halves of Rojo for you. It even has a nifty UI to sync files and start/stop the Rojo server!","title":"Installation"},{"location":"installation/#overview","text":"Rojo has two components: The command line interface (CLI) The Roblox Studio plugin Info It's important that your installed version of the plugin and CLI are compatible. The plugin will show errors in the Roblox Studio output window if there is a version mismatch.","title":"Overview"},{"location":"installation/#installing-the-cli","text":"","title":"Installing the CLI"},{"location":"installation/#installing-from-github","text":"If you're on Windows, there are pre-built binaries available from Rojo's GitHub Releases page . The Rojo CLI must be run from the command line, like Terminal.app on MacOS or cmd.exe on Windows. It's recommended that you put the Rojo CLI executable on your PATH to make this easier.","title":"Installing from GitHub"},{"location":"installation/#installing-from-cargo","text":"If you have Rust installed, the easiest way to get Rojo is with Cargo! To install the latest 0.5.0 alpha, use: cargo install rojo --version 0 .5.0-alpha.11","title":"Installing from Cargo"},{"location":"installation/#installing-the-plugin","text":"","title":"Installing the Plugin"},{"location":"installation/#installing-from-github_1","text":"The Rojo Roblox Studio plugin is available from Rojo's GitHub Releases page . Download the attached rbxm file and put it into your Roblox Studio plugins folder. You can find that folder by pressing Plugins Folder from your Plugins toolbar in Roblox Studio:","title":"Installing from GitHub"},{"location":"installation/#installing-from-robloxcom","text":"Visit Rojo's Roblox.com Plugin page in Roblox Studio and press Install .","title":"Installing from Roblox.com"},{"location":"installation/#visual-studio-code-extension","text":"If you use Visual Studio Code, you can install Evaera's unofficial Rojo extension , which will install both halves of Rojo for you. It even has a nifty UI to sync files and start/stop the Rojo server!","title":"Visual Studio Code Extension"},{"location":"migrating-to-epiphany/","text":"Rojo underwent a large refactor during most of 2018 to enable a bunch of new features and lay groundwork for lots more in 2019. As such, Rojo 0.5.x projects are not compatible with Rojo 0.4.x projects. Supporting Both 0.4.x and 0.5.x Upgrading Your Project File Migrating Unknown Files Supporting Both 0.4.x and 0.5.x \u00b6 Rojo 0.5.x uses a different name for its project format. While 0.4.x used rojo.json , 0.5.x uses default.project.json , which allows them to coexist. If you aren't sure about upgrading or want to upgrade gradually, it's possible to keep both files in the same project without causing problems. Upgrading Your Project File \u00b6 Project files in 0.5.x are more explicit and flexible than they were in 0.4.x. Project files can now describe models and plugins in addition to places. This new project file format also guards against two of the biggest pitfalls when writing a config file: Using a service as a partition target directly, which often wiped away extra instances Defining two partitions that overlapped, which made Rojo act unpredictably The biggest change is that the partitions field has been replaced with a new field, tree , that describes the entire hierarchy of your project from the top-down. A project for 0.4.x that syncs from the src directory into ReplicatedStorage.Source would look like this: { \"name\" : \"Rojo 0.4.x Example\" , \"partitions\" : { \"path\" : \"src\" , \"target\" : \"ReplicatedStorage.Source\" } } In 0.5.x, the project format is more explicit: { \"name\" : \"Rojo 0.5.x Example\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$className\" : \"ReplicatedStorage\" , \"Source\" : { \"$path\" : \"src\" } } } } For each object in the tree, we define metadata and children . Metadata begins with a dollar sign ( $ ), like $className . This is so that children and metadata can coexist without creating too many nested layers. All other values are considered children, where the key is the instance's name, and the value is an object, repeating the process. Migrating Unknown Files \u00b6 If you used Rojo to sync in files as StringValue objects, you'll need to make sure those files end with the txt extension to preserve this in Rojo 0.5.x. Unknown files are now ignored in Rojo instead of being converted to StringValue objects.","title":"Migrating from 0.4.x to 0.5.x"},{"location":"migrating-to-epiphany/#supporting-both-04x-and-05x","text":"Rojo 0.5.x uses a different name for its project format. While 0.4.x used rojo.json , 0.5.x uses default.project.json , which allows them to coexist. If you aren't sure about upgrading or want to upgrade gradually, it's possible to keep both files in the same project without causing problems.","title":"Supporting Both 0.4.x and 0.5.x"},{"location":"migrating-to-epiphany/#upgrading-your-project-file","text":"Project files in 0.5.x are more explicit and flexible than they were in 0.4.x. Project files can now describe models and plugins in addition to places. This new project file format also guards against two of the biggest pitfalls when writing a config file: Using a service as a partition target directly, which often wiped away extra instances Defining two partitions that overlapped, which made Rojo act unpredictably The biggest change is that the partitions field has been replaced with a new field, tree , that describes the entire hierarchy of your project from the top-down. A project for 0.4.x that syncs from the src directory into ReplicatedStorage.Source would look like this: { \"name\" : \"Rojo 0.4.x Example\" , \"partitions\" : { \"path\" : \"src\" , \"target\" : \"ReplicatedStorage.Source\" } } In 0.5.x, the project format is more explicit: { \"name\" : \"Rojo 0.5.x Example\" , \"tree\" : { \"$className\" : \"DataModel\" , \"ReplicatedStorage\" : { \"$className\" : \"ReplicatedStorage\" , \"Source\" : { \"$path\" : \"src\" } } } } For each object in the tree, we define metadata and children . Metadata begins with a dollar sign ( $ ), like $className . This is so that children and metadata can coexist without creating too many nested layers. All other values are considered children, where the key is the instance's name, and the value is an object, repeating the process.","title":"Upgrading Your Project File"},{"location":"migrating-to-epiphany/#migrating-unknown-files","text":"If you used Rojo to sync in files as StringValue objects, you'll need to make sure those files end with the txt extension to preserve this in Rojo 0.5.x. Unknown files are now ignored in Rojo instead of being converted to StringValue objects.","title":"Migrating Unknown Files"},{"location":"project-format/","text":"Project File Instance Description Instance Property Value Example Projects Project File \u00b6 Rojo projects are JSON files that have the .project.json extension. They have these fields: name : A string indicating the name of the project. This is only used for diagnostics. tree : An Instance Description describing the root instance of the project. Instance Description \u00b6 Instance Descriptions correspond one-to-one with the actual Roblox Instances in the project. They can be specified directly in the project file or be pulled from the filesystem. $className : The ClassName of the Instance being described. Optional if $path is specified. $path : The path on the filesystem to pull files from into the project. Optional if $className is specified. Paths are relative to the folder containing the project file. $properties : Properties to apply to the instance. Values should be Instance Property Values . Optional $ignoreUnknownInstances : Whether instances that Rojo doesn't know about should be deleted. Optional Default is false if $path is specified, otherwise true . All other fields in an Instance Description are turned into instances whose name is the key. These values should also be Instance Descriptions! Instance Descriptions are fairly verbose and strict. In the future, it'll be possible for Rojo to infer class names for known services like Workspace . Instance Property Value \u00b6 The shape of Instance Property Values is defined by the rbx_tree library, so it uses slightly different conventions than the rest of Rojo. Each value should be an object with the following required fields: Type : The type of property to represent. Supported types can be found here . Value : The value of the property. The shape of this field depends on which property type is being used. Vector3 and Color3 values are both represented as a list of numbers, for example. Instance Property Values are intentionally very strict. Rojo will eventually be able to infer types for you! Example Projects \u00b6 This project bundles up everything in the src directory. It'd be suitable for making a plugin or model: { \"name\" : \"AwesomeLibrary\" , \"tree\" : { \"$path\" : \"src\" } } This project describes the layout you might use if you were making the next hit simulator game, Sisyphus Simulator : { \"name\" : \"Sisyphus Simulator\" , \"tree\" : { \"$className\" : \"DataModel\" , \"HttpService\" : { \"$className\" : \"HttpService\" , \"$properties\" : { \"HttpEnabled\" : { \"Type\" : \"Bool\" , \"Value\" : true } } }, \"ReplicatedStorage\" : { \"$className\" : \"ReplicatedStorage\" , \"$path\" : \"src/ReplicatedStorage\" }, \"StarterPlayer\" : { \"$className\" : \"StarterPlayer\" , \"StarterPlayerScripts\" : { \"$className\" : \"StarterPlayerScripts\" , \"$path\" : \"src/StarterPlayerScripts\" } }, \"Workspace\" : { \"$className\" : \"Workspace\" , \"$properties\" : { \"Gravity\" : { \"Type\" : \"Float32\" , \"Value\" : 67.3 } }, \"Terrain\" : { \"$path\" : \"Terrain.rbxm\" } } } }","title":"Project Format"},{"location":"project-format/#project-file","text":"Rojo projects are JSON files that have the .project.json extension. They have these fields: name : A string indicating the name of the project. This is only used for diagnostics. tree : An Instance Description describing the root instance of the project.","title":"Project File"},{"location":"project-format/#instance-description","text":"Instance Descriptions correspond one-to-one with the actual Roblox Instances in the project. They can be specified directly in the project file or be pulled from the filesystem. $className : The ClassName of the Instance being described. Optional if $path is specified. $path : The path on the filesystem to pull files from into the project. Optional if $className is specified. Paths are relative to the folder containing the project file. $properties : Properties to apply to the instance. Values should be Instance Property Values . Optional $ignoreUnknownInstances : Whether instances that Rojo doesn't know about should be deleted. Optional Default is false if $path is specified, otherwise true . All other fields in an Instance Description are turned into instances whose name is the key. These values should also be Instance Descriptions! Instance Descriptions are fairly verbose and strict. In the future, it'll be possible for Rojo to infer class names for known services like Workspace .","title":"Instance Description"},{"location":"project-format/#instance-property-value","text":"The shape of Instance Property Values is defined by the rbx_tree library, so it uses slightly different conventions than the rest of Rojo. Each value should be an object with the following required fields: Type : The type of property to represent. Supported types can be found here . Value : The value of the property. The shape of this field depends on which property type is being used. Vector3 and Color3 values are both represented as a list of numbers, for example. Instance Property Values are intentionally very strict. Rojo will eventually be able to infer types for you!","title":"Instance Property Value"},{"location":"project-format/#example-projects","text":"This project bundles up everything in the src directory. It'd be suitable for making a plugin or model: { \"name\" : \"AwesomeLibrary\" , \"tree\" : { \"$path\" : \"src\" } } This project describes the layout you might use if you were making the next hit simulator game, Sisyphus Simulator : { \"name\" : \"Sisyphus Simulator\" , \"tree\" : { \"$className\" : \"DataModel\" , \"HttpService\" : { \"$className\" : \"HttpService\" , \"$properties\" : { \"HttpEnabled\" : { \"Type\" : \"Bool\" , \"Value\" : true } } }, \"ReplicatedStorage\" : { \"$className\" : \"ReplicatedStorage\" , \"$path\" : \"src/ReplicatedStorage\" }, \"StarterPlayer\" : { \"$className\" : \"StarterPlayer\" , \"StarterPlayerScripts\" : { \"$className\" : \"StarterPlayerScripts\" , \"$path\" : \"src/StarterPlayerScripts\" } }, \"Workspace\" : { \"$className\" : \"Workspace\" , \"$properties\" : { \"Gravity\" : { \"Type\" : \"Float32\" , \"Value\" : 67.3 } }, \"Terrain\" : { \"$path\" : \"Terrain.rbxm\" } } } }","title":"Example Projects"},{"location":"sync-details/","text":"This page aims to describe how Rojo turns files on the filesystem into Roblox objects. Overview Limitations Folders Scripts Localization Tables Plain Text Files JSON Models Binary and XML Models Overview \u00b6 File Name Instance Type any directory Folder *.server.lua Script *.client.lua LocalScript *.lua ModuleScript *.csv LocalizationTable *.txt StringValue *.model.json Any *.rbxm Any *.rbxmx Any Limitations \u00b6 Not all property types can be synced by Rojo in real-time due to limitations of the Roblox Studio plugin API. In these cases, you can usually generate a place file and open it when you start working on a project. Some common cases you might hit are: Binary data (Terrain, CSG, CollectionService tags) MeshPart.MeshId HttpService.HttpEnabled For a list of all property types that Rojo can reason about, both when live-syncing and when building place files, look at rbx_tree's type coverage chart . Folders \u00b6 Any directory on the filesystem will turn into a Folder instance unless it contains an 'init' script, described below. Scripts \u00b6 The default script type in Rojo projects is ModuleScript , since most scripts in well-structued Roblox projects will be modules. If a directory contains a file named init.server.lua , init.client.lua , or init.lua , that folder will be transformed into a *Script instance with the contents of the 'init' file. This can be used to create scripts inside of scripts. For example, these files: Will turn into these instances in Roblox: Localization Tables \u00b6 Any CSV files are transformed into LocalizationTable instances. Rojo expects these files to follow the same format that Roblox does when importing and exporting localization information. Plain Text Files \u00b6 Plain text files ( .txt ) files are transformed into StringValue instances. This is useful for bringing in text data that can be read by scripts at runtime. JSON Models \u00b6 Files ending in .model.json can be used to describe simple models. They're designed to be hand-written and are useful for instances like RemoteEvent . A JSON model describing a folder containing a Part and a RemoteEvent could be described as: { \"Name\" : \"My Cool Model\" , \"ClassName\" : \"Folder\" , \"Children\" : [ { \"Name\" : \"RootPart\" , \"ClassName\" : \"Part\" , \"Properties\" : { \"Size\" : { \"Type\" : \"Vector3\" , \"Value\" : [ 4 , 4 , 4 ] } } }, { \"Name\" : \"SendMoney\" , \"ClassName\" : \"RemoteEvent\" } ] } It would turn into instances in this shape: Binary and XML Models \u00b6 Rojo supports both binary ( .rbxm ) and XML ( .rbxmx ) models generated by Roblox Studio or another tool. Support for the rbxmx is very good, while support for rbxm is still very early, buggy, and lacking features. For a rundown of supported types, check out rbx-dom's type coverage chart .","title":"Sync Details"},{"location":"sync-details/#overview","text":"File Name Instance Type any directory Folder *.server.lua Script *.client.lua LocalScript *.lua ModuleScript *.csv LocalizationTable *.txt StringValue *.model.json Any *.rbxm Any *.rbxmx Any","title":"Overview"},{"location":"sync-details/#limitations","text":"Not all property types can be synced by Rojo in real-time due to limitations of the Roblox Studio plugin API. In these cases, you can usually generate a place file and open it when you start working on a project. Some common cases you might hit are: Binary data (Terrain, CSG, CollectionService tags) MeshPart.MeshId HttpService.HttpEnabled For a list of all property types that Rojo can reason about, both when live-syncing and when building place files, look at rbx_tree's type coverage chart .","title":"Limitations"},{"location":"sync-details/#folders","text":"Any directory on the filesystem will turn into a Folder instance unless it contains an 'init' script, described below.","title":"Folders"},{"location":"sync-details/#scripts","text":"The default script type in Rojo projects is ModuleScript , since most scripts in well-structued Roblox projects will be modules. If a directory contains a file named init.server.lua , init.client.lua , or init.lua , that folder will be transformed into a *Script instance with the contents of the 'init' file. This can be used to create scripts inside of scripts. For example, these files: Will turn into these instances in Roblox:","title":"Scripts"},{"location":"sync-details/#localization-tables","text":"Any CSV files are transformed into LocalizationTable instances. Rojo expects these files to follow the same format that Roblox does when importing and exporting localization information.","title":"Localization Tables"},{"location":"sync-details/#plain-text-files","text":"Plain text files ( .txt ) files are transformed into StringValue instances. This is useful for bringing in text data that can be read by scripts at runtime.","title":"Plain Text Files"},{"location":"sync-details/#json-models","text":"Files ending in .model.json can be used to describe simple models. They're designed to be hand-written and are useful for instances like RemoteEvent . A JSON model describing a folder containing a Part and a RemoteEvent could be described as: { \"Name\" : \"My Cool Model\" , \"ClassName\" : \"Folder\" , \"Children\" : [ { \"Name\" : \"RootPart\" , \"ClassName\" : \"Part\" , \"Properties\" : { \"Size\" : { \"Type\" : \"Vector3\" , \"Value\" : [ 4 , 4 , 4 ] } } }, { \"Name\" : \"SendMoney\" , \"ClassName\" : \"RemoteEvent\" } ] } It would turn into instances in this shape:","title":"JSON Models"},{"location":"sync-details/#binary-and-xml-models","text":"Rojo supports both binary ( .rbxm ) and XML ( .rbxmx ) models generated by Roblox Studio or another tool. Support for the rbxmx is very good, while support for rbxm is still very early, buggy, and lacking features. For a rundown of supported types, check out rbx-dom's type coverage chart .","title":"Binary and XML Models"},{"location":"why-rojo/","text":"There are a number of existing plugins for Roblox that move code from the filesystem into Roblox. Besides Rojo, you might consider: rbxmk by Anaminus Rofresh by Osyris RbxRefresh by Osyris Studio Bridge by Vocksel Elixir by Vocksel RbxSync by evaera CodeSync by MemoryPenguin rbx-exteditor by MemoryPenguin So why did I build Rojo? Each of these tools solves what is essentially the same problem from a few different angles. The goal of Rojo is to take all of the lessons and ideas learned from these projects and build a tool that can solve this problem for good. Additionally: I think that this tool needs to be built in a compiled language without a runtime, for easy distribution and good performance. I think that the conventions promoted by other sync plugins ( .module.lua for modules, as well a single sync point) are sub-optimal. I think that I have a good enough understanding of the problem to build something robust. I think that Rojo should be able to do more than just sync code.","title":"Why Rojo?"},{"location":"internals/overview/","text":"This document aims to give a general overview of how Rojo works. It's intended for people who want to contribute to the project as well as anyone who's just curious how the tool works! CLI RbxTree In-Memory Filesystem (IMFS) Snapshot Reconciler HTTP API Roblox Studio Plugin CLI \u00b6 RbxTree \u00b6 Rojo uses a library named rbx_tree as its implementation of the Roblox DOM. It serves as a common format for serialization to all the formats Rojo supports! Rojo uses two related libraries to deserialize instances from Roblox's file formats, rbx_xml and rbx_binary . In-Memory Filesystem (IMFS) \u00b6 Relevant source files: server/src/imfs.rs server/src/fs_watcher.rs Rojo keeps an in-memory copy of all files that it needs reasons about. This enables taking fast, stateless, tear-tree snapshots of files to turn them into instances. Keeping an in-memory copy of file contents will also enable Rojo to debounce changes that are caused by Rojo itself. This'll happen when two-way sync finally happens. Snapshot Reconciler \u00b6 Relevant source files: server/src/snapshot_reconciler.rs server/src/rbx_snapshot.rs server/src/rbx_session.rs To simplify incremental updates of instances, Rojo generates lightweight snapshots describing how files map to instances. This means that Rojo can treat file change events similarly to damage painting as opposed to trying to surgically update the correct instances. This approach reduces the number of desynchronization bugs, reduces the complexity of important pieces of the codebase, and makes writing plugins a lot easier. HTTP API \u00b6 Relevant source files: server/src/web.rs The Rojo live-sync server and Roblox Studio plugin communicate via HTTP. Requests sent from the plugin to the server are regular HTTP requests. Messages sent from the server to the plugin are delivered via HTTP long-polling. This is an approach that uses long-lived HTTP requests that restart on timeout. It's largely been replaced by WebSockets, but Roblox doesn't have support for them. Roblox Studio Plugin \u00b6 TODO","title":"Internals Overview"},{"location":"internals/overview/#cli","text":"","title":"CLI"},{"location":"internals/overview/#rbxtree","text":"Rojo uses a library named rbx_tree as its implementation of the Roblox DOM. It serves as a common format for serialization to all the formats Rojo supports! Rojo uses two related libraries to deserialize instances from Roblox's file formats, rbx_xml and rbx_binary .","title":"RbxTree"},{"location":"internals/overview/#in-memory-filesystem-imfs","text":"Relevant source files: server/src/imfs.rs server/src/fs_watcher.rs Rojo keeps an in-memory copy of all files that it needs reasons about. This enables taking fast, stateless, tear-tree snapshots of files to turn them into instances. Keeping an in-memory copy of file contents will also enable Rojo to debounce changes that are caused by Rojo itself. This'll happen when two-way sync finally happens.","title":"In-Memory Filesystem (IMFS)"},{"location":"internals/overview/#snapshot-reconciler","text":"Relevant source files: server/src/snapshot_reconciler.rs server/src/rbx_snapshot.rs server/src/rbx_session.rs To simplify incremental updates of instances, Rojo generates lightweight snapshots describing how files map to instances. This means that Rojo can treat file change events similarly to damage painting as opposed to trying to surgically update the correct instances. This approach reduces the number of desynchronization bugs, reduces the complexity of important pieces of the codebase, and makes writing plugins a lot easier.","title":"Snapshot Reconciler"},{"location":"internals/overview/#http-api","text":"Relevant source files: server/src/web.rs The Rojo live-sync server and Roblox Studio plugin communicate via HTTP. Requests sent from the plugin to the server are regular HTTP requests. Messages sent from the server to the plugin are delivered via HTTP long-polling. This is an approach that uses long-lived HTTP requests that restart on timeout. It's largely been replaced by WebSockets, but Roblox doesn't have support for them.","title":"HTTP API"},{"location":"internals/overview/#roblox-studio-plugin","text":"TODO","title":"Roblox Studio Plugin"}]}